# pré-requis

Cette journée nécessite un cluster PostgreSQL et un cluster Corosync
pré-configurés sur les même machines. Un fichier `Vagrantfile` est disponible
dans le dépôt pour créer trois machines, installer et configurer l'ensemble.

La seule commande à lancer est :

```bash
vagrant up
```

Cette dernière crée les machines et lance un playbook ansible.

Une fois le playbook ansible terminé, vous devriez avoir une instance primaire
sur la machine `s1`, et un standby sur `s2` et `s3`. Les standby ne sont
cependant pas encore en mesure de se connecter au primaire et attende une
configuration adéquate.

Coté corosync, vous devriez observer un cluster avec les trois nœuds connectés
ensemble :

```console
# corosync-cfgtool -s
Local node ID 1, transport knet
LINK ID 0 udp
	addr	= 192.168.121.223
	status:
		nodeid:          1:	localhost
		nodeid:          2:	connected
		nodeid:          3:	connected
```


# Cycle de développement

L'architecture obtenue par défaut n'installe pas le module CPG, c'est à vous de
le développer !

Durant votre cycle de développement, vous pouvez resynchroniser votre module
sur tous les nœuds du cluster avec la commande suivante :

```bash
vagrant rsync
```

La variante `rsync-auto` existe, selon vos préférences.

Une fois le code source distribué et mis à jour sur tous les nœuds, un playbook
ansible permet d'installer les paquets nécessaire, compiler le module,
l'installer et le configurer au sein du cluster :

```bash
vagrant provision --provision-with=cpg
```

Pour éviter certaines phases inutiles, il est aussi possible d'utiliser :

```bash
vagrant --ansible-tags=cpg_build provision --provision-with=cpg
```
